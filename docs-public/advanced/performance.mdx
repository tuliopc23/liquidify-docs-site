# Performance Optimization

Maximize your app's performance with LiqUIdify's built-in optimizations and best practices. Our components are designed for speed, but following these guidelines ensures optimal results.

## Bundle Size Optimization

### Tree Shaking and Subpath Imports
LiqUIdify supports granular imports to minimize bundle size. Import only the components you need:

```tsx
// ✅ Recommended: Subpath imports
import { Button } from "liquidify-react/button"
import { Card } from "liquidify-react/card"
import { Dialog } from "liquidify-react/dialog"

// ❌ Avoid: Barrel imports
import { Button, Card, Dialog } from "liquidify-react"
```

### CSS Loading Strategy
Import styles once at your application root to avoid duplication:

```tsx
// app/layout.tsx (Next.js) or main.tsx (Vite)
import "liquidify-react/styles"

function RootLayout({ children }) {
	return (
		<html>
			<body>{children}</body>
		</html>
	)
}
```

### Bundle Analysis
Monitor your bundle size with these tools:

```bash
# Webpack Bundle Analyzer
npm install --save-dev webpack-bundle-analyzer
npx webpack-bundle-analyzer build/static/js/*.js

# Vite Bundle Analyzer
npm install --save-dev rollup-plugin-visualizer
# Add to vite.config.ts plugins array
```

## Runtime Performance

### Component Lazy Loading
Load components on-demand for faster initial page loads:

```tsx
import { lazy, Suspense } from "react"

const Dialog = lazy(() => import("liquidify-react/dialog").then(m => ({ default: m.Dialog })))
const DataTable = lazy(() => import("liquidify-react/data-table").then(m => ({ default: m.DataTable })))

function App() {
	return (
		<Suspense fallback={<div>Loading...</div>}>
			<Dialog />
			<DataTable />
		</Suspense>
	)
}
```

### Memoization Strategies
Use React's built-in optimization hooks with LiqUIdify components:

```tsx
import { memo, useMemo, useCallback } from "react"
import { Button } from "liquidify-react/button"

const OptimizedComponent = memo(function MyComponent({ items, onItemClick }) {
	const sortedItems = useMemo(() => 
		items.sort((a, b) => a.name.localeCompare(b.name)), 
		[items]
	)

	const handleClick = useCallback((id: string) => {
		onItemClick(id)
	}, [onItemClick])

	return (
		<div>
			{sortedItems.map(item => (
				<Button key={item.id} onClick={() => handleClick(item.id)}>
					{item.name}
				</Button>
			))}
		</div>
	)
})
```

## Server-Side Rendering (SSR)

### Hydration Optimization
Prevent hydration mismatches with proper server/client handling:

```tsx
import { useEffect, useState } from "react"
import { ThemeProvider } from "liquidify-react/theme"

function App({ children }) {
	const [mounted, setMounted] = useState(false)

	useEffect(() => {
		setMounted(true)
	}, [])

	if (!mounted) {
		return <div>{children}</div>
	}

	return (
		<ThemeProvider>
			{children}
		</ThemeProvider>
	)
}
```

### Static Generation
Pre-render pages with LiqUIdify components for optimal performance:

```tsx
// Next.js Static Generation
export async function getStaticProps() {
	return {
		props: {
			// Pre-fetch data for static rendering
		}
	}
}

// Astro Static Generation
---
// Components render at build time
import { Card } from "liquidify-react/card"
---
<Card>Pre-rendered content</Card>
```

## Animation Performance

### Hardware Acceleration
LiqUIdify animations use GPU-accelerated transforms:

```css
/* Built into LiqUIdify components */
.liquidify-dialog {
	transform: translateZ(0); /* Force hardware acceleration */
	will-change: transform, opacity;
}
```

### Reduce Motion Preferences
Respect user accessibility preferences:

```tsx
import { useReducedMotion } from "liquidify-react/hooks"

function AnimatedComponent() {
	const shouldReduceMotion = useReducedMotion()
	
	return (
		<div
			style={{
				transition: shouldReduceMotion ? "none" : "all 0.2s ease"
			}}
		>
			Content
		</div>
	)
}
```

## Memory Management

### Event Listener Cleanup
LiqUIdify components automatically clean up event listeners, but ensure your custom code follows suit:

```tsx
import { useEffect } from "react"

function useKeyboardShortcut(key: string, callback: () => void) {
	useEffect(() => {
		function handleKeyPress(event: KeyboardEvent) {
			if (event.key === key) callback()
		}

		document.addEventListener("keydown", handleKeyPress)
		return () => document.removeEventListener("keydown", handleKeyPress)
	}, [key, callback])
}
```

### Ref Management
Properly handle refs to prevent memory leaks:

```tsx
import { useRef, useEffect } from "react"
import { Button } from "liquidify-react/button"

function Component() {
	const buttonRef = useRef<HTMLButtonElement>(null)

	useEffect(() => {
		const button = buttonRef.current
		if (!button) return

		// Setup
		const observer = new IntersectionObserver(/* ... */)
		observer.observe(button)

		// Cleanup
		return () => {
			observer.unobserve(button)
			observer.disconnect()
		}
	}, [])

	return <Button ref={buttonRef}>Click me</Button>
}
```

## Performance Monitoring

### Core Web Vitals
Track performance metrics in production:

```tsx
import { getCLS, getFID, getFCP, getLCP, getTTFB } from "web-vitals"

function sendToAnalytics(metric) {
	// Send to your analytics provider
	console.log(metric)
}

getCLS(sendToAnalytics)
getFID(sendToAnalytics)
getFCP(sendToAnalytics)
getLCP(sendToAnalytics)
getTTFB(sendToAnalytics)
```

### Component Performance Profiling
Use React DevTools Profiler to identify bottlenecks:

```tsx
import { Profiler } from "react"

function onRenderCallback(id, phase, actualDuration) {
	console.log(`${id} (${phase}) took ${actualDuration}ms`)
}

function App() {
	return (
		<Profiler id="App" onRender={onRenderCallback}>
			{/* Your LiqUIdify components */}
		</Profiler>
	)
}
```

## Production Checklist

- [ ] Using subpath imports for tree shaking
- [ ] CSS imported once at app root
- [ ] Large components lazy loaded
- [ ] Expensive computations memoized
- [ ] Event listeners properly cleaned up
- [ ] Bundle size analyzed and optimized
- [ ] Core Web Vitals monitored
- [ ] SSR hydration handled correctly
- [ ] Reduced motion preferences respected

## Related Guides

- [Installing LiqUIdify](../guides/installing) - Framework-specific setup
- [Tree Shaking Guide](../guides/importing) - Import optimization strategies
- [Accessibility](./accessibility) - Performance impact of accessibility features
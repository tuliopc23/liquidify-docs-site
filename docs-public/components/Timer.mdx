---
title: "Timer"
description: "A customizable timer component for countdown and stopwatch functionality"
---

# Timer

A flexible timer component that supports both countdown and stopwatch modes with customizable time units and controls. Perfect for tracking time-based activities, deadlines, or any scenario requiring precise time management.

## Installation

```bash
npm install @liquidify/components
```

## Import

```tsx
import { Timer } from "@liquidify/components/timer";
```

## Usage

### Basic Timer (Stopwatch)

```tsx
import { Timer } from "@liquidify/components/timer";

export default function BasicTimer() {
  return (
    <Timer />
  );
}
```

### Countdown Timer

```tsx
import { Timer } from "@liquidify/components/timer";

export default function CountdownTimer() {
  const fiveMinutes = 5 * 60 * 1000; // 5 minutes in milliseconds

  return (
    <Timer 
      startMs={fiveMinutes}
      countdown
    />
  );
}
```

### Timer with Target

```tsx
import { Timer } from "@liquidify/components/timer";

export default function TimerWithTarget() {
  const targetTime = 10 * 60 * 1000; // 10 minutes in milliseconds

  return (
    <Timer 
      targetMs={targetTime}
      onTargetReached={() => {
        alert("Target time reached!");
      }}
    />
  );
}
```

### Custom Timer Format

```tsx
import { Timer } from "@liquidify/components/timer";

export default function CustomFormatTimer() {
  return (
    <Timer>
      {(api) => (
        <div style={{ 
          display: "flex", 
          flexDirection: "column", 
          alignItems: "center",
          gap: "1rem"
        }}>
          <div style={{ 
            fontSize: "2rem", 
            fontFamily: "monospace",
            display: "flex",
            gap: "0.5rem"
          }}>
            <span>{api.formattedTime.hours.padStart(2, "0")}</span>
            <span>:</span>
            <span>{api.formattedTime.minutes.padStart(2, "0")}</span>
            <span>:</span>
            <span>{api.formattedTime.seconds.padStart(2, "0")}</span>
          </div>
          
          <div style={{ display: "flex", gap: "0.5rem" }}>
            <button onClick={api.start} disabled={api.running}>
              Start
            </button>
            <button onClick={api.pause} disabled={!api.running}>
              Pause
            </button>
            <button onClick={api.reset}>
              Reset
            </button>
          </div>
        </div>
      )}
    </Timer>
  );
}
```

### Pomodoro Timer

```tsx
import { useState } from "react";
import { Timer } from "@liquidify/components/timer";

export default function PomodoroTimer() {
  const [session, setSession] = useState("work");
  const [cycles, setCycles] = useState(0);

  const workTime = 25 * 60 * 1000; // 25 minutes
  const breakTime = 5 * 60 * 1000; // 5 minutes
  const longBreakTime = 15 * 60 * 1000; // 15 minutes

  const getCurrentTime = () => {
    if (session === "work") return workTime;
    if (session === "break") return breakTime;
    return longBreakTime;
  };

  const handleTargetReached = () => {
    if (session === "work") {
      const newCycles = cycles + 1;
      setCycles(newCycles);
      
      if (newCycles % 4 === 0) {
        setSession("longBreak");
      } else {
        setSession("break");
      }
    } else {
      setSession("work");
    }
  };

  return (
    <div style={{ textAlign: "center" }}>
      <h2>Pomodoro Timer</h2>
      <p>Current Session: <strong>
        {session === "work" ? "Work" : 
         session === "break" ? "Short Break" : "Long Break"}
      </strong></p>
      <p>Completed Cycles: {cycles}</p>
      
      <Timer 
        key={session} // Reset timer when session changes
        startMs={getCurrentTime()}
        countdown
        onTargetReached={handleTargetReached}
      />
    </div>
  );
}
```

### Meeting Timer

```tsx
import { useState } from "react";
import { Timer } from "@liquidify/components/timer";

export default function MeetingTimer() {
  const [meetingLength, setMeetingLength] = useState(30);
  const [isStarted, setIsStarted] = useState(false);

  const meetingTime = meetingLength * 60 * 1000;

  return (
    <div style={{ textAlign: "center", padding: "2rem" }}>
      <h2>Meeting Timer</h2>
      
      {!isStarted ? (
        <div>
          <div style={{ marginBottom: "1rem" }}>
            <label>
              Meeting Length: 
              <select 
                value={meetingLength} 
                onChange={(e) => setMeetingLength(Number(e.target.value))}
                style={{ marginLeft: "0.5rem" }}
              >
                <option value={15}>15 minutes</option>
                <option value={30}>30 minutes</option>
                <option value={45}>45 minutes</option>
                <option value={60}>1 hour</option>
                <option value={90}>1.5 hours</option>
              </select>
            </label>
          </div>
          <button onClick={() => setIsStarted(true)}>
            Start Meeting
          </button>
        </div>
      ) : (
        <div>
          <Timer 
            startMs={meetingTime}
            countdown
            onTargetReached={() => {
              alert("Meeting time is up!");
            }}
          >
            {(api) => (
              <div>
                <div style={{ 
                  fontSize: "3rem", 
                  fontFamily: "monospace",
                  marginBottom: "1rem",
                  color: api.formattedTime.minutes < 5 ? "red" : "inherit"
                }}>
                  {api.formattedTime.minutes.padStart(2, "0")}:
                  {api.formattedTime.seconds.padStart(2, "0")}
                </div>
                
                <div style={{ display: "flex", gap: "0.5rem", justifyContent: "center" }}>
                  <button onClick={api.start} disabled={api.running}>
                    Start
                  </button>
                  <button onClick={api.pause} disabled={!api.running}>
                    Pause
                  </button>
                  <button onClick={() => setIsStarted(false)}>
                    End Meeting
                  </button>
                </div>
                
                {api.formattedTime.minutes < 5 && api.running && (
                  <p style={{ color: "red", marginTop: "1rem" }}>
                    ⚠️ Less than 5 minutes remaining!
                  </p>
                )}
              </div>
            )}
          </Timer>
        </div>
      )}
    </div>
  );
}
```

### Multiple Timers

```tsx
import { useState } from "react";
import { Timer } from "@liquidify/components/timer";

export default function MultipleTimers() {
  const [timers, setTimers] = useState([
    { id: 1, name: "Task 1", duration: 10 * 60 * 1000 },
    { id: 2, name: "Task 2", duration: 15 * 60 * 1000 },
    { id: 3, name: "Task 3", duration: 20 * 60 * 1000 },
  ]);

  return (
    <div style={{ display: "grid", gap: "2rem", gridTemplateColumns: "repeat(auto-fit, minmax(300px, 1fr))" }}>
      {timers.map((timer) => (
        <div key={timer.id} style={{ 
          border: "1px solid #ccc", 
          padding: "1rem", 
          borderRadius: "8px",
          textAlign: "center"
        }}>
          <h3>{timer.name}</h3>
          <Timer 
            startMs={timer.duration}
            countdown
            onTargetReached={() => {
              alert(`${timer.name} completed!`);
            }}
          />
        </div>
      ))}
    </div>
  );
}
```

## API Reference

### Timer

The timer component with built-in controls and display.

#### Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `startMs` | `number` | `0` | Starting time in milliseconds |
| `targetMs` | `number` | - | Target time in milliseconds |
| `countdown` | `boolean` | `false` | Whether to count down instead of up |
| `autoStart` | `boolean` | `false` | Whether to start automatically |
| `onTargetReached` | `() => void` | - | Callback when target time is reached |
| `onTick` | `(time: number) => void` | - | Callback fired on each tick |
| `interval` | `number` | `10` | Update interval in milliseconds |
| `children` | `(api: TimerApi) => ReactNode` | - | Render prop for custom display |

### Timer API (when using children render prop)

| Property | Type | Description |
|----------|------|-------------|
| `time` | `number` | Current time in milliseconds |
| `formattedTime` | `FormattedTime` | Formatted time object |
| `running` | `boolean` | Whether the timer is currently running |
| `paused` | `boolean` | Whether the timer is paused |
| `start()` | `function` | Start the timer |
| `pause()` | `function` | Pause the timer |
| `resume()` | `function` | Resume the timer |
| `reset()` | `function` | Reset the timer |

### FormattedTime Object

| Property | Type | Description |
|----------|------|-------------|
| `days` | `string` | Days component |
| `hours` | `string` | Hours component |
| `minutes` | `string` | Minutes component |
| `seconds` | `string` | Seconds component |
| `milliseconds` | `string` | Milliseconds component |

## Accessibility

The Timer component includes comprehensive accessibility features:

- **ARIA Labels**: Implements proper ARIA labels for timer status
- **Keyboard Support**: All controls are keyboard accessible
- **Screen Reader Support**: Announces time changes and status updates
- **Focus Management**: Proper focus handling for controls
- **High Contrast**: Compatible with high contrast themes

### Keyboard Shortcuts

| Key | Action |
|-----|--------|
| `Space` | Start/pause the timer |
| `Enter` | Activate focused control |
| `Tab` | Navigate between controls |
| `Escape` | Reset the timer (when focused) |

## Best Practices

1. **Clear Purpose**: Make the timer's purpose and current state obvious to users
2. **Visual Feedback**: Provide clear visual indicators for different timer states
3. **Appropriate Precision**: Choose the right level of precision for your use case
4. **Performance**: Consider the update interval based on your needs
5. **Notifications**: Provide appropriate feedback when targets are reached
6. **Responsive Design**: Ensure timers work well on different screen sizes
7. **Accessibility**: Always provide proper labeling for screen readers

---
title: "SegmentGroup"
description: "Segmented control component for mutually exclusive option selection"
---

# SegmentGroup

A segmented control component that allows users to select one option from a set of mutually exclusive choices. Perfect for view switches, filter controls, mode selectors, or any scenario requiring clean, compact option selection with a unified visual design.

## Installation

```bash
npm install @liquidify/components
```

## Import

```tsx
import { SegmentGroup } from "@liquidify/components/segmentGroup";
```

## Usage

### Basic Segment Group

```tsx
import { useState } from "react";
import { SegmentGroup } from "@liquidify/components/segmentGroup";

export default function BasicSegmentGroup() {
  const [value, setValue] = useState("option1");

  return (
    <div style={{ padding: "2rem" }}>
      <h3>Select an option</h3>

      <SegmentGroup.Root value={value} onValueChange={(details) => setValue(details.value)}>
        <SegmentGroup.Item value="option1">
          <SegmentGroup.ItemText>Option 1</SegmentGroup.ItemText>
          <SegmentGroup.ItemControl />
        </SegmentGroup.Item>

        <SegmentGroup.Item value="option2">
          <SegmentGroup.ItemText>Option 2</SegmentGroup.ItemText>
          <SegmentGroup.ItemControl />
        </SegmentGroup.Item>

        <SegmentGroup.Item value="option3">
          <SegmentGroup.ItemText>Option 3</SegmentGroup.ItemText>
          <SegmentGroup.ItemControl />
        </SegmentGroup.Item>
      </SegmentGroup.Root>

      <p style={{ marginTop: "1rem" }}>Selected: <strong>{value}</strong></p>
    </div>
  );
}
```

### View Mode Selector

```tsx
import { useState } from "react";
import { SegmentGroup } from "@liquidify/components/segmentGroup";

export default function ViewModeSelector() {
  const [viewMode, setViewMode] = useState("grid");

  const items = [
    { value: "list", label: "List", icon: "üìã" },
    { value: "grid", label: "Grid", icon: "‚öè" },
    { value: "card", label: "Card", icon: "üÉè" }
  ];

  return (
    <div style={{ padding: "2rem" }}>
      <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "2rem" }}>
        <h3>Product Catalog</h3>

        <SegmentGroup.Root value={viewMode} onValueChange={(details) => setViewMode(details.value)}>
          {items.map(item => (
            <SegmentGroup.Item key={item.value} value={item.value}>
              <SegmentGroup.ItemText>
                {item.icon} {item.label}
              </SegmentGroup.ItemText>
              <SegmentGroup.ItemControl />
            </SegmentGroup.Item>
          ))}
        </SegmentGroup.Root>
      </div>

      <div style={{
        padding: "2rem",
        border: "1px solid #dee2e6",
        borderRadius: "8px",
        textAlign: "center",
        backgroundColor: "#f8f9fa"
      }}>
        <h4>Current View: {items.find(item => item.value === viewMode)?.label}</h4>
        <p>Displaying products in {viewMode} mode</p>

        {viewMode === "list" && (
          <div>
            <div style={{ display: "flex", justifyContent: "space-between", padding: "0.5rem", borderBottom: "1px solid #dee2e6" }}>
              <span>Product Name</span>
              <span>Price</span>
            </div>
            <div style={{ display: "flex", justifyContent: "space-between", padding: "0.5rem" }}>
              <span>Sample Product</span>
              <span>$29.99</span>
            </div>
          </div>
        )}

        {viewMode === "grid" && (
          <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(150px, 1fr))", gap: "1rem" }}>
            {[1, 2, 3, 4].map(i => (
              <div key={i} style={{ padding: "1rem", backgroundColor: "white", borderRadius: "4px" }}>
                <div style={{ width: "100%", height: "80px", backgroundColor: "#e9ecef", marginBottom: "0.5rem" }}></div>
                <div>Product {i}</div>
                <div>$29.99</div>
              </div>
            ))}
          </div>
        )}

        {viewMode === "card" && (
          <div style={{ display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(250px, 1fr))", gap: "1rem" }}>
            {[1, 2].map(i => (
              <div key={i} style={{ padding: "1rem", backgroundColor: "white", borderRadius: "8px", boxShadow: "0 2px 4px rgba(0,0,0,0.1)" }}>
                <div style={{ width: "100%", height: "120px", backgroundColor: "#e9ecef", marginBottom: "1rem", borderRadius: "4px" }}></div>
                <h5>Product {i}</h5>
                <p>This is a detailed description of the product with more information about its features and benefits.</p>
                <div style={{ fontWeight: "bold", color: "#007bff" }}>$29.99</div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
```

### Text Formatting Controls

```tsx
import { useState } from "react";
import { SegmentGroup } from "@liquidify/components/segmentGroup";

export default function TextFormattingControls() {
  const [alignment, setAlignment] = useState("left");
  const [fontSize, setFontSize] = useState("medium");

  const sampleText = "The quick brown fox jumps over the lazy dog. This is a sample text to demonstrate the formatting controls.";

  return (
    <div style={{ padding: "2rem", maxWidth: "600px", margin: "0 auto" }}>
      <h3>Text Editor</h3>

      <div style={{ marginBottom: "2rem" }}>
        <h4>Text Alignment</h4>
        <SegmentGroup.Root value={alignment} onValueChange={(details) => setAlignment(details.value)}>
          <SegmentGroup.Item value="left">
            <SegmentGroup.ItemText>‚¨ÖÔ∏è Left</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>

          <SegmentGroup.Item value="center">
            <SegmentGroup.ItemText>‚¨å Center</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>

          <SegmentGroup.Item value="right">
            <SegmentGroup.ItemText>‚û°Ô∏è Right</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>

          <SegmentGroup.Item value="justify">
            <SegmentGroup.ItemText>‚¨å Justify</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>
        </SegmentGroup.Root>
      </div>

      <div style={{ marginBottom: "2rem" }}>
        <h4>Font Size</h4>
        <SegmentGroup.Root value={fontSize} onValueChange={(details) => setFontSize(details.value)}>
          <SegmentGroup.Item value="small">
            <SegmentGroup.ItemText>Small</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>

          <SegmentGroup.Item value="medium">
            <SegmentGroup.ItemText>Medium</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>

          <SegmentGroup.Item value="large">
            <SegmentGroup.ItemText>Large</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>

          <SegmentGroup.Item value="xlarge">
            <SegmentGroup.ItemText>X-Large</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>
        </SegmentGroup.Root>
      </div>

      <div style={{
        padding: "1rem",
        border: "1px solid #dee2e6",
        borderRadius: "8px",
        backgroundColor: "#f8f9fa",
        textAlign: alignment,
        fontSize: fontSize === "small" ? "14px" :
                  fontSize === "medium" ? "16px" :
                  fontSize === "large" ? "18px" : "20px",
        lineHeight: alignment === "justify" ? "1.6" : "1.4"
      }}>
        <h4>Preview</h4>
        <p>{sampleText}</p>
      </div>
    </div>
  );
}
```

### Filter Controls

```tsx
import { useState } from "react";
import { SegmentGroup } from "@liquidify/components/segmentGroup";

export default function FilterControls() {
  const [statusFilter, setStatusFilter] = useState("all");
  const [sortBy, setSortBy] = useState("date");

  const tasks = [
    { id: 1, title: "Complete project proposal", status: "completed", date: "2024-01-15" },
    { id: 2, title: "Review design mockups", status: "in-progress", date: "2024-01-16" },
    { id: 3, title: "Update documentation", status: "pending", date: "2024-01-17" },
    { id: 4, title: "Fix login bug", status: "completed", date: "2024-01-14" },
    { id: 5, title: "Plan team meeting", status: "pending", date: "2024-01-18" }
  ];

  const filteredTasks = tasks.filter(task => {
    if (statusFilter === "all") return true;
    return task.status === statusFilter;
  });

  const sortedTasks = [...filteredTasks].sort((a, b) => {
    if (sortBy === "date") {
      return new Date(b.date) - new Date(a.date);
    }
    return a.title.localeCompare(b.title);
  });

  const getStatusColor = (status) => {
    switch (status) {
      case "completed": return "#28a745";
      case "in-progress": return "#007bff";
      case "pending": return "#ffc107";
      default: return "#6c757d";
    }
  };

  return (
    <div style={{ padding: "2rem", maxWidth: "800px", margin: "0 auto" }}>
      <h3>Task Manager</h3>

      <div style={{ marginBottom: "2rem" }}>
        <h4>Filter by Status</h4>
        <SegmentGroup.Root value={statusFilter} onValueChange={(details) => setStatusFilter(details.value)}>
          <SegmentGroup.Item value="all">
            <SegmentGroup.ItemText>üìã All</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>

          <SegmentGroup.Item value="pending">
            <SegmentGroup.ItemText>‚è≥ Pending</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>

          <SegmentGroup.Item value="in-progress">
            <SegmentGroup.ItemText>üîÑ In Progress</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>

          <SegmentGroup.Item value="completed">
            <SegmentGroup.ItemText>‚úÖ Completed</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>
        </SegmentGroup.Root>
      </div>

      <div style={{ marginBottom: "2rem" }}>
        <h4>Sort By</h4>
        <SegmentGroup.Root value={sortBy} onValueChange={(details) => setSortBy(details.value)}>
          <SegmentGroup.Item value="date">
            <SegmentGroup.ItemText>üìÖ Date</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>

          <SegmentGroup.Item value="title">
            <SegmentGroup.ItemText>üìù Title</SegmentGroup.ItemText>
            <SegmentGroup.ItemControl />
          </SegmentGroup.Item>
        </SegmentGroup.Root>
      </div>

      <div>
        <h4>Tasks ({sortedTasks.length})</h4>
        <div style={{ display: "flex", flexDirection: "column", gap: "0.5rem" }}>
          {sortedTasks.map(task => (
            <div key={task.id} style={{
              padding: "1rem",
              border: "1px solid #dee2e6",
              borderRadius: "8px",
              backgroundColor: "white",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center"
            }}>
              <div>
                <h5 style={{ margin: 0 }}>{task.title}</h5>
                <small style={{ color: "#666" }}>{task.date}</small>
              </div>
              <span style={{
                padding: "0.25rem 0.5rem",
                borderRadius: "12px",
                fontSize: "0.8rem",
                color: "white",
                backgroundColor: getStatusColor(task.status)
              }}>
                {task.status.replace("-", " ")}
              </span>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
```

### Theme Selector

```tsx
import { useState } from "react";
import { SegmentGroup } from "@liquidify/components/segmentGroup";

export default function ThemeSelector() {
  const [theme, setTheme] = useState("light");

  const themes = {
    light: {
      name: "Light",
      icon: "‚òÄÔ∏è",
      colors: { bg: "#ffffff", text: "#333333", accent: "#007bff" }
    },
    dark: {
      name: "Dark",
      icon: "üåô",
      colors: { bg: "#1a1a1a", text: "#ffffff", accent: "#4dabf7" }
    },
    auto: {
      name: "Auto",
      icon: "üîÑ",
      colors: { bg: "#f8f9fa", text: "#333333", accent: "#28a745" }
    }
  };

  const currentTheme = themes[theme];

  return (
    <div style={{
      padding: "2rem",
      maxWidth: "600px",
      margin: "0 auto",
      backgroundColor: currentTheme.colors.bg,
      color: currentTheme.colors.text,
      borderRadius: "12px",
      transition: "all 0.3s ease"
    }}>
      <h3>Theme Settings</h3>

      <div style={{ marginBottom: "2rem" }}>
        <h4>Choose Theme</h4>
        <SegmentGroup.Root value={theme} onValueChange={(details) => setTheme(details.value)}>
          {Object.entries(themes).map(([key, themeData]) => (
            <SegmentGroup.Item key={key} value={key}>
              <SegmentGroup.ItemText>
                {themeData.icon} {themeData.name}
              </SegmentGroup.ItemText>
              <SegmentGroup.ItemControl />
            </SegmentGroup.Item>
          ))}
        </SegmentGroup.Root>
      </div>

      <div style={{
        padding: "2rem",
        backgroundColor: theme === "dark" ? "#2d2d2d" : "#f8f9fa",
        borderRadius: "8px",
        border: `2px solid ${currentTheme.colors.accent}`
      }}>
        <h4>Preview</h4>
        <p>This is how your content will look with the <strong>{currentTheme.name}</strong> theme.</p>

        <div style={{ marginTop: "1rem" }}>
          <button style={{
            padding: "0.5rem 1rem",
            backgroundColor: currentTheme.colors.accent,
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer"
          }}>
            Sample Button
          </button>
        </div>

        <div style={{ marginTop: "1rem", display: "flex", flexDirection: "column", gap: "0.5rem" }}>
          <div style={{ height: "4px", backgroundColor: currentTheme.colors.accent, borderRadius: "2px" }}></div>
          <div style={{ height: "4px", backgroundColor: currentTheme.colors.accent, borderRadius: "2px", width: "80%" }}></div>
          <div style={{ height: "4px", backgroundColor: currentTheme.colors.accent, borderRadius: "2px", width: "60%" }}></div>
        </div>
      </div>
    </div>
  );
}
```

### Unit Converter

```tsx
import { useState } from "react";
import { SegmentGroup } from "@liquidify/components/segmentGroup";

export default function UnitConverter() {
  const [fromUnit, setFromUnit] = useState("celsius");
  const [toUnit, setToUnit] = useState("fahrenheit");
  const [inputValue, setInputValue] = useState("");

  const temperatureUnits = [
    { value: "celsius", label: "Celsius", symbol: "¬∞C" },
    { value: "fahrenheit", label: "Fahrenheit", symbol: "¬∞F" },
    { value: "kelvin", label: "Kelvin", symbol: "K" }
  ];

  const convertTemperature = (value, from, to) => {
    if (!value || isNaN(value)) return "";

    const numValue = parseFloat(value);

    // Convert to Celsius first
    let celsius;
    switch (from) {
      case "celsius":
        celsius = numValue;
        break;
      case "fahrenheit":
        celsius = (numValue - 32) * 5/9;
        break;
      case "kelvin":
        celsius = numValue - 273.15;
        break;
      default:
        return "";
    }

    // Convert from Celsius to target unit
    switch (to) {
      case "celsius":
        return celsius.toFixed(2);
      case "fahrenheit":
        return (celsius * 9/5 + 32).toFixed(2);
      case "kelvin":
        return (celsius + 273.15).toFixed(2);
      default:
        return "";
    }
  };

  const result = convertTemperature(inputValue, fromUnit, toUnit);

  return (
    <div style={{ padding: "2rem", maxWidth: "500px", margin: "0 auto" }}>
      <h3>Temperature Converter</h3>

      <div style={{ marginBottom: "2rem" }}>
        <label style={{ display: "block", marginBottom: "0.5rem" }}>
          From
        </label>
        <SegmentGroup.Root value={fromUnit} onValueChange={(details) => setFromUnit(details.value)}>
          {temperatureUnits.map(unit => (
            <SegmentGroup.Item key={unit.value} value={unit.value}>
              <SegmentGroup.ItemText>{unit.label}</SegmentGroup.ItemText>
              <SegmentGroup.ItemControl />
            </SegmentGroup.Item>
          ))}
        </SegmentGroup.Root>
      </div>

      <div style={{ marginBottom: "2rem" }}>
        <label style={{ display: "block", marginBottom: "0.5rem" }}>
          To
        </label>
        <SegmentGroup.Root value={toUnit} onValueChange={(details) => setToUnit(details.value)}>
          {temperatureUnits.map(unit => (
            <SegmentGroup.Item key={unit.value} value={unit.value}>
              <SegmentGroup.ItemText>{unit.label}</SegmentGroup.ItemText>
              <SegmentGroup.ItemControl />
            </SegmentGroup.Item>
          ))}
        </SegmentGroup.Root>
      </div>

      <div style={{ marginBottom: "2rem" }}>
        <label style={{ display: "block", marginBottom: "0.5rem" }}>
          Enter Value
        </label>
        <input
          type="number"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="Enter temperature"
          style={{
            width: "100%",
            padding: "0.5rem",
            border: "1px solid #ccc",
            borderRadius: "4px",
            fontSize: "16px"
          }}
        />
      </div>

      <div style={{
        padding: "1rem",
        backgroundColor: "#f8f9fa",
        borderRadius: "8px",
        textAlign: "center"
      }}>
        <h4>Result</h4>
        {result ? (
          <div style={{ fontSize: "24px", fontWeight: "bold", color: "#007bff" }}>
            {inputValue} {temperatureUnits.find(u => u.value === fromUnit)?.symbol} =
            <br />
            {result} {temperatureUnits.find(u => u.value === toUnit)?.symbol}
          </div>
        ) : (
          <div style={{ color: "#666" }}>
            Enter a value to see the conversion
          </div>
        )}
      </div>
    </div>
  );
}
```

### Media Player Controls

```tsx
import { useState } from "react";
import { SegmentGroup } from "@liquidify/components/segmentGroup";

export default function MediaPlayerControls() {
  const [playbackSpeed, setPlaybackSpeed] = useState("1x");
  const [quality, setQuality] = useState("auto");

  const speeds = [
    { value: "0.5x", label: "0.5x" },
    { value: "1x", label: "Normal" },
    { value: "1.25x", label: "1.25x" },
    { value: "1.5x", label: "1.5x" },
    { value: "2x", label: "2x" }
  ];

  const qualities = [
    { value: "auto", label: "Auto" },
    { value: "720p", label: "720p" },
    { value: "1080p", label: "1080p" },
    { value: "4k", label: "4K" }
  ];

  return (
    <div style={{ padding: "2rem", maxWidth: "600px", margin: "0 auto" }}>
      <h3>Video Player Settings</h3>

      <div style={{ marginBottom: "2rem" }}>
        <h4>Playback Speed</h4>
        <SegmentGroup.Root value={playbackSpeed} onValueChange={(details) => setPlaybackSpeed(details.value)}>
          {speeds.map(speed => (
            <SegmentGroup.Item key={speed.value} value={speed.value}>
              <SegmentGroup.ItemText>{speed.label}</SegmentGroup.ItemText>
              <SegmentGroup.ItemControl />
            </SegmentGroup.Item>
          ))}
        </SegmentGroup.Root>
      </div>

      <div style={{ marginBottom: "2rem" }}>
        <h4>Video Quality</h4>
        <SegmentGroup.Root value={quality} onValueChange={(details) => setQuality(details.value)}>
          {qualities.map(q => (
            <SegmentGroup.Item key={q.value} value={q.value}>
              <SegmentGroup.ItemText>{q.label}</SegmentGroup.ItemText>
              <SegmentGroup.ItemControl />
            </SegmentGroup.Item>
          ))}
        </SegmentGroup.Root>
      </div>

      <div style={{
        padding: "2rem",
        backgroundColor: "#1a1a1a",
        color: "white",
        borderRadius: "8px",
        textAlign: "center"
      }}>
        <div style={{ fontSize: "48px", marginBottom: "1rem" }}>‚ñ∂Ô∏è</div>
        <h4>Sample Video Player</h4>
        <p>Playback Speed: <strong>{playbackSpeed}</strong></p>
        <p>Quality: <strong>{quality}</strong></p>

        <div style={{ marginTop: "1rem", display: "flex", justifyContent: "center", gap: "1rem" }}>
          <button style={{
            padding: "0.5rem 1rem",
            backgroundColor: "#007bff",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer"
          }}>
            Play
          </button>
          <button style={{
            padding: "0.5rem 1rem",
            backgroundColor: "#6c757d",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer"
          }}>
            Pause
          </button>
        </div>
      </div>
    </div>
  );
}
```

## API Reference

### SegmentGroup.Root

The root container for the segment group component.

#### Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `value` | `string` | - | The controlled value |
| `defaultValue` | `string` | - | The default value when uncontrolled |
| `onValueChange` | `(details: ValueChangeDetails) => void` | - | Callback fired when value changes |
| `disabled` | `boolean` | `false` | Whether the segment group is disabled |
| `orientation` | `"horizontal" \| "vertical"` | `"horizontal"` | The orientation of the segment group |
| `children` | `ReactNode` | - | The segment group content |

### SegmentGroup.Item

An individual segment item within the group.

#### Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `value` | `string` | - | The unique value for this segment item |
| `disabled` | `boolean` | `false` | Whether this item is disabled |
| `children` | `ReactNode` | - | The segment item content |

### SegmentGroup.ItemText

The text content for a segment item.

#### Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `children` | `ReactNode` | - | The text content |

### SegmentGroup.ItemControl

The interactive control element for a segment item.

#### Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `children` | `ReactNode` | - | The control content |

### SegmentGroup.Indicator

A visual indicator for the selected segment.

#### Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `children` | `ReactNode` | - | The indicator content |

## Accessibility

The SegmentGroup component includes comprehensive accessibility features:

- **ARIA Roles**: Implements proper radiogroup and radio roles
- **Keyboard Navigation**: Full keyboard support for navigating between segments
- **Screen Reader Support**: Announces selection changes and available options
- **Focus Management**: Proper focus handling and visual indicators
- **High Contrast**: Compatible with high contrast themes

### Keyboard Shortcuts

| Key | Action |
|-----|--------|
| `Tab` | Move focus into the segment group |
| `Arrow Left/Right` | Navigate between segments (horizontal) |
| `Arrow Up/Down` | Navigate between segments (vertical) |
| `Space` / `Enter` | Select the focused segment |
| `Home` | Move to first segment |
| `End` | Move to last segment |

## Best Practices

1. **Clear Labels**: Use descriptive text or icons that clearly indicate each option
2. **Logical Grouping**: Group related options that make sense together
3. **Consistent Styling**: Maintain consistent styling across all segment items
4. **Appropriate Number**: Limit to 3-5 options to avoid overwhelming users
5. **Visual Hierarchy**: Make the selected state clearly distinguishable
6. **Responsive Design**: Consider how segments adapt to different screen sizes
7. **Default Selection**: Provide a sensible default selection when appropriate
8. **Progressive Enhancement**: Ensure functionality works without JavaScript
